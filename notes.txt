###############################################################################
############################## SPRING CLOUD ###################################
###############################################################################

Arquitectura:

       +---------+     +------------+      +----------------+    +----------+
       |         |     |    Load    |      |                |    | Logging  |
       |  Edge   | ->  |  Balancer  |  ->  | MICROSERVICIOS | -> |          |
       | Service |     +------------+      |                |    +----------+
       |         |           ^  |          |                |
  ->   |         |           |  v          |                |    +----------+
       |         |     +------------+      |     Circuit    |    | Configu- |
       |         |     |  Registry  |  <-  |     Breaker    | <- |  ración  |
       +---------+     +------------+      +----------------+    +----------+

Spring Boot - Spring Cloud:

       +---------+     +------------+      +----------------+    +----------+
       |         |     |   Ribbon   |      |                |    | Logging  |
       |         | ->  |            |  ->  | MICROSERVICIOS | -> |Log4,ELK..|
       | Gateway |     +------------+      |                |    +----------+
       |         |           ^  |          |                |
  ->   |         |           |  v          |                |    +------------+
       |         |     +------------+      |     Hystrix    |    |Spring,Cloud|
       |         |     |   Eureka   |  <-  |                | <- | Config,etc.|
       +---------+     +------------+      +----------------+    +------------+



Los Microservicios, son tanto una arquitectura como un modo para desarrollar software que consiste en contruir una
aplicación como un conjunto de pequeños servicios independientes entre sí, los cuales se ejecutan en su propio
proceso y se comunican  con mecanismos ligeros (normalmente una API REST).

Ventajas:

- Escalabilidad: Escalado eficiente, elástico y horizontal aumentando o disminuyendo la cantidad de microservicios
  de acuerdo a la demanda. Brinda la alta disponibilidad.
- Modularidad: Cada servicio tiene un función acotada. Lo hará bien produciendo eficiencia y Simplicidad.
- Heterogeneos: Cada microservicio puede ser desarrollado en una tecnología diferente, lenguaje, DB, pero integrandose
  como una sola aplicación.
- Desacoplamiento: Cada microservicio se despliega independientemente.
- Rápido despliegue: Integración y despliegue continuo usando contenedores.


Con Spring Boot Starter Web, nuestro servicio contendrá una clase principal que arranca la aplicación, arranca un
apache tomcat embebido.
Esta clase tendrá la anotación @SpringBootApplication, y será una interface que tiene la anotación
@SpringBootConfiguration para cargar las configuraciones (resources > application.properties) y @
ComponentScan para hacer un escaneo de todas las clases del proyecto.

########################## CLOUD CONFIG SERVER ################################

- Servidor de configuración centralizado
- Jerarquia de configuración (A través de profiles:dev,qa, vamos a definir las configuraciones para distintos entornos)
- Histórico de configuración (la configuración se puede registrar en un controlador de versiones como github, gitlab..)
- Recarga de valores de propiedades en caliente.

########## DEPENDENCIES:

Config Server (Spring Cloud Config)
Spring Security (Security)

########## ACTIVAR PROYECTO (CLASE PRINCIPAL):

- Activar el proyecto como un servidor de configuración
  Colocamos la anotación @EnableConfigServer en la clase pricipal.

##########

- Si queremos que el archivo que contenga los datos de configuración del config-service se llame
  bootstrap.yml y no application.yml, debemos agregar la siguiente dependencia:

    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-bootstrap</artifactId>
    </dependency>

- El archivo application.yml / application.properties es específico de las aplicaciones Spring Boot. A menos que
  cambie la ubicación de las propiedades externas de una aplicación, Spring Boot siempre cargará application.yml
  desde la siguiente ubicación:
  /src/main/resources/application.yml

  bootstrap.yml

  bootstrap.yml, por otro lado, es específico de spring-cloud-config y se carga antes que application.yml
  bootstrap.yml solo es necesario si está utilizando Spring Cloud y su configuración de microservicio está almacenada
  en un Spring Cloud Config Server remoto.

  1. Cuando se usa con el servidor Spring Cloud Config, debe especificar el nombre de la aplicación y la ubicación de
     configuración de git usando las propiedades a continuación.

     spring.application.name: "nombre de la aplicación"
     spring.cloud.config.server.git.uri: "git-uri-config"

  2. Cuando se usa con microservicios (que no sean el servidor de configuración en la nube), necesitamos especificar
     el nombre de la aplicación y la ubicación del servidor de configuración usando las propiedades siguientes.

  Source:
  https://stackoverflow.com/questions/32997352/what-is-the-difference-between-putting-a-property-on-application-yml-or-bootstra

- Los servicios deben conectarse al config-server al ya no tener su archivo de propiedades (application.yml)
  Se le creará el archivo bootstrap.yml que indicará la uri donde se levanta el config server para obtener su configuración.

  customer-service/src/main/resources/bootstrap.yml:
  spring:
    application:
      name: customer-service
    cloud:
      config:
        uri: http://localhost:8081
        username: root
        password: s3cr3t

- En el config server se puede definir una autenticación gracias a Spring Security:
  config-service/src/main/resources/bootstrap.yml:
  spring:
    security:
      user:
        name: root
        password: s3cr3t

  Y de esta forma para acceder al config-server cuando se levanta debemos ingresar el userName y password,
  si es através de una petición REST colocando Authentication y las credenciales, y si es através de un microservicio
  definir las credenciales en su bootstrap.yml

- Especificamos la ubicación del repositorio central con las configuraciones de los microservicios con:
  spring:
    cloud:
      config:
        server:
          git:
            uri: https://github.com/CiprianoBryan/JAVA-Microservices-2.git
            search-paths: config-data
            username: ${GIT_USER}
            password: ${GIT_PASSWORD}
  Si es un repositorio remoto colocamos el usuario y contraseña de la cuenta.
  Si es un archivo local solo colocamos el uri:
    file:///F:/Cursos_Udemy/Master_Microservices_with_Spring_Boot_and_Spring_Cloud/Practice/git-localconfig-repo/

############################## EUREKA SERVER ##################################

- Nos permite el registro y localización de instancias de Microservicios que están corriendo.
- Cada instancia de Microservicio (con Eureka Client) notifica su estado al Eureka server cada 30s (heartbeats).
- Cada Microservicio cachea una copia del registro de Eureka Server para saber cuales son los Microservicios ejecutandose
  en el Eureka server.
- Funciona en modo cluster, es recomendable cuando se lanza en producción.
- Modo Selft-Preservation, entra en este modo cuando un número de Microservicios registrados no notifican su estado de
  salud a Eureka Server, de esta manera Eureka Server determina que hay problemas en la red.

########## DEPENDENCIES:

Eureka Server (Spring Cloud Discovery)
Config Client (Spring Cloud Config)

########## ACTIVAR PROYECTO (CLASE PRINCIPAL):

- Activar el proyecto para que trabaje como un Eureka Server
  Colocamos la anotación @EnableEurekaServer en la clase pricipal.
- En el repositorio central de configuración (config-data) colocaremos el archivo de configuración del EurekaServer

########## PROPERTIE FILE:
propertie files in config data (Repo Central Config):

- registry-service.yml (Eureka server): Definimos eureka.client.service-url.default-zone:
    http://${eureka.instance.hostname}:${server.port}/eureka/
  Con esto indicamos donde se está lanzando nuestro Eureka Server
- <microservice-application-name>.yml :
- customer-service.yml (Microservicio): Definimos eureka.client.service-url.default-zone:
    http://localhost:8099/eureka/
  Con esto indicamos donde se encuentra nuestro Eureka Server para que el microservicio se registre.

########## MICROSERVICIOS:

- Además en los microservicios que se registraran debemos añadir la dependencia:
    Eureka Client:
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

  También agregar la anotación @EnableEurekaClient en la clase principal del microservicio.

###############################################################################
############################## DEPENDENCIAS ###################################
###############################################################################

Spring Web: Provee apache tomcat embebido, crear aplicaciones API RESTful.
Spring Data JPA: Para el manejo de la base de datos.
H2 Database: Es una base de datos en memoria.
Lombok: Libreria de anotaciones Java (reducción de código).
Config Client: Para la conexión con el servidor Spring Cloud Config.
Eureka Discovery Client: Registrar servicios, y aplicar Load Balancer.
Sleuth: DISTRIBUTED TRACING, es una libreria que asigna un ID único a cada solicitud.

###############################################################################
################################# PAQUETES ####################################
###############################################################################

> entity: Contiene las clases que representan a las tablas de la base de datos.
> repository: Contiene las interfaces los cuales tienen métodos que interactuaran con la BD.
  - Desde la capa de servicio se hará uso de estas clases, con Autowired las inyectaremos.
> Service: Los métodos que van a definir la capa de servicio.
> Controller: Clases API REST, donde usaremos las clases de la capa de servicio.

###############################################################################
################################## DATOS ######################################
###############################################################################

- @Entity: Para definir nuestras clases como entidad.
- @Table(name = "table_name"): Usamos cuando el nombre de nuestra tabla es distinta de nuestra clase.
- @Id: Para inidicar nuestra llave primaria.
- @GeneratedValue(strategy = GenerationType.IDENTITY): Para que el valor sea autoincrementable.
- @Data = @Getter + @Setter + @HashCode + @ToString + Equals
- @Column(name = "create_at"): Lo usamos solo cuando el nombre del campo de la clase sea distinto al de la BD.
- @Temporal(TemporalType.TIMESTAMP): Definimos el formato del tiempo en el campo seleccionado.
- @ManyToOne(fetch = FetchType.LAZY): Relación ManyToOne, Lazy carga los datos solo cuando se le llame.
- @JoinColumn(name = "category_id"): Indica que campo será la clave foranea indicada en name.
- JpaRepository: Se colocan la entidad del repositorio y el tipo de dato de la llave primaria (Id).
  > Reemplaza la clase DAO.
  > Implementa varios métodos que utilizaremos, además extiende de:
  > PagingAndSorting..: Para el paginado automático.
  > QueryBy..: Genera automáticamente las querys.
- @AllArgsConstructor: Agregar un constructor con todos los campos.
- @NoArgsConstructor: Agregar un constructor sin argumentos.
- @Builder: Para construir nuevas instancias de la entidad.
- @DataJpaTest: Anotación a colocar en una clase test para evaluar el repository, nos provee toda la configuración JPA
- @SpringBootTest: Anotación a colocar en una clase test de la capa de servicio.
- @Mock: Utilizado cuando no queremos inyectar una clase y usar los métodos como tal, sino simularla.
- @BeforeEach: Para ejecutar el método al inicio cada vez que se corre la clase test.
- Al usar @Autowired, se inyectan automáticamente las dependencias de una clase (ejm: repository) que se usa como
  atributo en otra (service), y en caso como por ejm de crear una clase Test para testear la clase (service),
  tendriamos como atributo a la clase (service), al cual debemos inicializarla y pasarle todos sus atributos,
  incluyendo clases (repository), y es por esto último que no se podría construir la clase (service) ya que su
  parámetro clase (repository) se inyecta automáticamente por lo que no se puede enviar una con valores.

  * Class service:
  @Service
  public class ProductServiceImpl implements ProductService {
      @Autowired
      private ProductRepository productRepository;

  * Class Test:
  @SpringBootTest
  public class ProductServiceMockTest {
      @Mock
      private ProductRepository productRepository;
      private ProductService productService;

      @BeforeEach
      private void setup() {
          productService = new ProductServiceImpl(productRepository);  ... ERROR
      }
  }

  Por ello, se debe cambiar el @Autowired para que permita inicializar el atributo clase (repository).
  Y que a la vez también se inyecte automáticamente. Esto se puede lograr realizando el cambio de que la
  inyección no se realice desde la declaración del atributo clase (repository) sino dentro del constructor,
  es decir que si se pasa el valor del atributo al construir la clase (service), esta se colocará inyectará automáticamente,
  o viceversa, si se pasa el atributo clase (service), esta se inicializará con esos valores.

  @RequiredArgsConstructor: Se hace una inyección de dependencias por constructor.

- @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"}): Lo usamos cuando hacemos uso del tipo Lazy en un entity
  para definir la estrategia en la relación con otra tabla, esto nos evita un error que se genera al imprimir el entity.
- @Valid: Lo colocamos al lado del campo que queremos que se apliquen las validaciones definidad en su entity.
  Validaciones como:
  @Positive(message = "El stock debe ser mayor que cero")
  @NotEmpty(message = "El nombre no debe ser vacío")
  @NotNull(message = "La categoría no debe ser vacia")
  BindingResult:
  Debemos agregar también un parámetro del tipo BindingResult, el cual contendrá el resultado con todos los errores.

  * ProductController:
  @PostMapping
      public ResponseEntity<Product> createProduct(@Valid @RequestBody Product product, BindingResult result) {

- @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
  CascadeType.ALL significa que hará todas las demás acciones:
  > CascadeType.PERSIST: Cuando persiste una entidad, también persisten las entidades que se encuentran en sus campos.
  > CascadeType.REMOVE: Al eliminar una entidad, también elimina las entidades contenidas en este campo.
  > CascadeType.REFRESH: al actualizar una entidad, también actualice las entidades contenidas en este campo.
  > CascadeType.MERGE: al fusionar el estado de la entidad, fusiona también las entidades contenidas en este campo.

- @Valid: Se puede colocar dentro de un campo de una entity para que se apliquen sus validaciones.
- @PrePersist: Para registrar automáticamente antes de insertar en la Base de Datos. Es decir aplicarle alguna acción.
- @Transient: Lo colocamos en el atributo que no queremos registrar en nuestra base de datos.
- @EnableConfigServer: Activa el proyecto como un servidor de configuración al colocar la anotación en la clase pricipal.