###############################################################################
############################## SPRING CLOUD ###################################
###############################################################################

Arquitectura:

       +---------+     +------------+      +----------------+    +----------+
       |         |     |    Load    |      |                |    | Logging  |
       |  Edge   | ->  |  Balancer  |  ->  | MICROSERVICIOS | -> |          |
       | Service |     +------------+      |                |    +----------+
       |         |           ^  |          |                |
  ->   |         |           |  v          |                |    +----------+
       |         |     +------------+      |     Circuit    |    | Configu- |
       |         |     |  Registry  |  <-  |     Breaker    | <- |  ración  |
       +---------+     +------------+      +----------------+    +----------+

Spring Boot - Spring Cloud:

       +---------+     +------------+      +----------------+    +----------+
       |         |     |   Ribbon   |      |                |    | Logging  |
       |         | ->  |            |  ->  | MICROSERVICIOS | -> |Log4,ELK..|
       | Gateway |     +------------+      |                |    +----------+
       |         |           ^  |          |                |
  ->   |         |           |  v          |                |    +------------+
       |         |     +------------+      |     Hystrix    |    |Spring,Cloud|
       |         |     |   Eureka   |  <-  |                | <- | Config,etc.|
       +---------+     +------------+      +----------------+    +------------+



Los Microservicios, son tanto una arquitectura como un modo para desarrollar software que consiste en contruir una
aplicación como un conjunto de pequeños servicios independientes entre sí, los cuales se ejecutan en su propio
proceso y se comunican  con mecanismos ligeros (normalmente una API REST).

Ventajas:

- Escalabilidad: Escalado eficiente, elástico y horizontal aumentando o disminuyendo la cantidad de microservicios
  de acuerdo a la demanda. Brinda la alta disponibilidad.
- Modularidad: Cada servicio tiene un función acotada. Lo hará bien produciendo eficiencia y Simplicidad.
- Heterogeneos: Cada microservicio puede ser desarrollado en una tecnología diferente, lenguaje, DB, pero integrandose
  como una sola aplicación.
- Desacoplamiento: Cada microservicio se despliega independientemente.
- Rápido despliegue: Integración y despliegue continuo usando contenedores.


Con Spring Boot Starter Web, nuestro servicio contendrá una clase principal que arranca la aplicación, arranca un
apache tomcat embebido.
Esta clase tendrá la anotación @SpringBootApplication, y será una interface que tiene la anotación
@SpringBootConfiguration para cargar las configuraciones (resources > application.properties) y @
ComponentScan para hacer un escaneo de todas las clases del proyecto

###############################################################################
############################## DEPENDENCIAS ###################################
###############################################################################

Spring Web: Provee apache tomcat embebido, crear aplicaciones API RESTful.
Spring Data JPA: Para el manejo de la base de datos.
H2 Database: Es una base de datos en memoria.
Lombok: Libreria de anotaciones Java (reducción de código).
Config Client: Para la conexión con el servidor Spring Cloud Config.
Eureka Discovery Client: Registrar servicios, y aplicar Load Balancer.
Sleuth: DISTRIBUTED TRACING, es una libreria que asigna un ID único a cada solicitud.

###############################################################################
################################# PAQUETES ####################################
###############################################################################

> entity: Contiene las clases que representan a las tablas de la base de datos.
> repository: Contiene las interfaces los cuales tienen métodos que interactuaran con la BD.
  - Desde la capa de servicio se hará uso de estas clases, con Autowired las inyectaremos.
> Service: Los métodos que van a definir la capa de servicio.

###############################################################################
################################## DATOS ######################################
###############################################################################

- @Entity: Para definir nuestras clases como entidad.
- @Table(name = "table_name"): Usamos cuando el nombre de nuestra tabla es distinta de nuestra clase.
- @Id: Para inidicar nuestra llave primaria.
- @GeneratedValue(strategy = GenerationType.IDENTITY): Para que el valor sea autoincrementable.
- @Data = @Getter + @Setter + @HashCode + @ToString + Equals
- @Column(name = "create_at"): Lo usamos solo cuando el nombre del campo de la clase sea distinto al de la BD.
- @Temporal(TemporalType.TIMESTAMP): Definimos el formato del tiempo en el campo seleccionado.
- @ManyToOne(fetch = FetchType.LAZY): Relación ManyToOne, Lazy carga los datos solo cuando se le llame.
- @JoinColumn(name = "category_id"): Indica que campo será la clave foranea indicada en name.
- JpaRepository: Se colocan la entidad del repositorio y el tipo de dato de la llave primaria (Id).
  > Reemplaza la clase DAO.
  > Implementa varios métodos que utilizaremos, además extiende de:
  > PagingAndSorting..: Para el paginado automático.
  > QueryBy..: Genera automáticamente las querys.
- @AllArgsConstructor: Agregar un constructor con todos los campos.
- @NoArgsConstructor: Agregar un constructor sin argumentos.
- @Builder: Para construir nuevas instancias de la entidad.
- @DataJpaTest: Anotación a colocar en una clase test para evaluar el repository, nos provee toda la configuración JPA
- @SpringBootTest: Anotación a colocar en una clase test de la capa de servicio.
- @Mock: Utilizado cuando no queremos inyectar una clase y usar los métodos como tal, sino simularla.
- @BeforeEach: Para ejecutar el método al inicio cada vez que se corre la clase test.
- Al usar @Autowired, se inyectan automáticamente las dependencias de una clase (ejm: repository) que se usa como
  atributo en otra (service), y en caso como por ejm de crear una clase Test para testear la clase (service),
  tendriamos como atributo a la clase (service), al cual debemos inicializarla y pasarle todos sus atributos,
  incluyendo clases (repository), y es por esto último que no se podría construir la clase (service) ya que su
  parámetro clase (repository) se inyecta automáticamente por lo que no se puede enviar una con valores.

  * Class service:
  @Service
  public class ProductServiceImpl implements ProductService {
      @Autowired
      private ProductRepository productRepository;

  * Class Test:
  @SpringBootTest
  public class ProductServiceMockTest {
      @Mock
      private ProductRepository productRepository;
      private ProductService productService;

      @BeforeEach
      private void setup() {
          productService = new ProductServiceImpl(productRepository);  ... ERROR
      }
  }

  Por ello, se debe cambiar el @Autowired para que permita inicializar el atributo clase (repository).
  Y que a la vez también se inyecte automáticamente. Esto se puede lograr realizando el cambio de que la
  inyección no se realice desde la declaración del atributo clase (repository) sino dentro del constructor,
  es decir que si se pasa el valor del atributo al construir la clase (service), esta se colocará inyectará automáticamente,
  o viceversa, si se pasa el atributo clase (service), esta se inicializará con esos valores.

  @RequiredArgsConstructor: Se hace una inyección de dependencias por constructor.

