###############################################################################
############################## SPRING CLOUD ###################################
###############################################################################

Arquitectura:

       +---------+     +------------+      +----------------+    +----------+
       |         |     |    Load    |      |                |    | Logging  |
       |  Edge   | ->  |  Balancer  |  ->  | MICROSERVICIOS | -> |          |
       | Service |     +------------+      |                |    +----------+
       |         |           ^  |          |                |
  ->   |         |           |  v          |                |    +----------+
       |         |     +------------+      |     Circuit    |    | Configu- |
       |         |     |  Registry  |  <-  |     Breaker    | <- |  ración  |
       +---------+     +------------+      +----------------+    +----------+

Spring Boot - Spring Cloud:

       +---------+     +------------+      +----------------+    +----------+
       |         |     |   Ribbon   |      |                |    | Logging  |
       |         | ->  |            |  ->  | MICROSERVICIOS | -> |Log4,ELK..|
       | Gateway |     +------------+      |                |    +----------+
       |         |           ^  |          |                |
  ->   |         |           |  v          |                |    +------------+
       |         |     +------------+      |     Hystrix    |    |Spring,Cloud|
       |         |     |   Eureka   |  <-  |                | <- | Config,etc.|
       +---------+     +------------+      +----------------+    +------------+



Los Microservicios, son tanto una arquitectura como un modo para desarrollar software que consiste en contruir una
aplicación como un conjunto de pequeños servicios independientes entre sí, los cuales se ejecutan en su propio
proceso y se comunican  con mecanismos ligeros (normalmente una API REST).

Ventajas:

- Escalabilidad: Escalado eficiente, elástico y horizontal aumentando o disminuyendo la cantidad de microservicios
  de acuerdo a la demanda. Brinda la alta disponibilidad.
- Modularidad: Cada servicio tiene un función acotada. Lo hará bien produciendo eficiencia y Simplicidad.
- Heterogeneos: Cada microservicio puede ser desarrollado en una tecnología diferente, lenguaje, DB, pero integrandose
  como una sola aplicación.
- Desacoplamiento: Cada microservicio se despliega independientemente.
- Rápido despliegue: Integración y despliegue continuo usando contenedores.


Con Spring Boot Starter Web, nuestro servicio contendrá una clase principal que arranca la aplicación, arranca un
apache tomcat embebido.
Esta clase tendrá la anotación @SpringBootApplication, y será una interface que tiene la anotación
@SpringBootConfiguration para cargar las configuraciones (resources > application.properties) y @
ComponentScan para hacer un escaneo de todas las clases del proyecto

###############################################################################
############################## DEPENDENCIAS ###################################
###############################################################################

Spring Web: Provee apache tomcat embebido, crear aplicaciones API RESTful.
Spring Data JPA: Para el manejo de la base de datos.
H2 Database: Es una base de datos en memoria.
Lombok: Libreria de anotaciones Java (reducción de código).
Config Client: Para la conexión con el servidor Spring Cloud Config.
Eureka Discovery Client: Registrar servicios, y aplicar Load Balancer.
Sleuth: DISTRIBUTED TRACING, es una libreria que asigna un ID único a cada solicitud.

###############################################################################
################################## DATOS ######################################
###############################################################################

- @Entity: Para definir nuestras clases como entidad.
- @Table(name = "table_name"): Usamos cuando el nombre de nuestra tabla es distinta de nuestra clase.
- @Id: Para inidicar nuestra llave primaria.
- @GeneratedValue(strategy = GenerationType.IDENTITY): Para que el valor sea autoincrementable.
- @Data = @Getter + @Setter + @HashCode + @ToString + Equals
- @Column(name = "create_at"): Lo usamos solo cuando el nombre del campo de la clase sea distinto al de la BD.
- @Temporal(TemporalType.TIMESTAMP): Definimos el formato del tiempo en el campo seleccionado.
- @ManyToOne(fetch = FetchType.LAZY): Relación ManyToOne, Lazy carga los datos solo cuando se le llame.
- @JoinColumn(name = "category_id"): Indica que campo será la clave foranea indicada en name.
- JpaRepository: Se colocan la entidad del repositorio y el tipo de dato de la llave primaria (Id).
  > Reemplaza la clase DAO.
  > Implementa varios métodos que utilizaremos, además extiende de:
  > PagingAndSorting..: Para el paginado automático.
  > QueryBy..: Genera automáticamente las querys.